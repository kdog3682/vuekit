import * as csx from "/home/kdog3682/2024-javascript/csx/main.js"
import {traverse, Traversal, inAndOut} from "/home/kdog3682/2024-javascript/js-toolkit/traverse.js"

import {StateContextNode} from "/home/kdog3682/2024-javascript/js-toolkit/StateContextNode.js"
import lazyObjectTraversal from "/home/kdog3682/2024-javascript/js-toolkit/lop.js"

/* prettier-ignore */ import {fooga, mconfig, unreachable, notify, storager, joiner, removeVeryStartingComments, ireplace, removeCommentsInPlace, editf, getLineTokens, IndexedStore, abstractError, bool, xassert, getSetLines, inMiddle, replaceLast, ensureExtension, multipleReplacer, getGradeLevel, constructEdit, getYear, Modulus, wrapClassMethods, proseReplacer, parseComments, parseFunctionDictComments, todo, dictAssertion, boundModularIncrement, construct, reduceToString2, pageTurner, assignCumulative, defaultMergeStrategy, dictSetter3, toArguments, reTemplate, parseFrontmatter, typeAssertion, defineGetter, assignAllowed, simpleRecursiveWalk, simpleArgument, exprTemplater, stringifyIfNotPrimitive, panic, stringerf, wrapFunction, regexTemplater, iso8601, strftime, walkChildEntries, getFiletype, matchf, isUrl, looksLikeFunction, toArgument2, notNull, CumulativeStorage2, simpleAssign, findAndMatch, infuseObjectArray, regexGetter, splitArg, isJavascriptComment, runTest, everyOther, splitByRange, get_regex, getImports, isJavascriptFile, isValidDateString, WriteObject, equalityf, group2, splitOnce2, dedent4, isLowerCase, looksLikeRegExpString, isRegExpString, getDependencies, camelSplit, toggle3, countf, isLiteralObject, bindMethodsAndState2, call, mget3, looks_like_object_function, create_functions_from_master, toStringArgumentPretty, codeChunks, smart_map, run_tests, hasStartingCallable, mapTemplate, aliaser, fixSelector, htmlTags, removePythonComments, simpleStringBreaker, colonConfig, operations, error, redColon, so2, group, parseSingleLineJson, Items, findDependencies, tryf, find4, localeString, cssComment, colonConfigf, trimArray, parseCallable, bringToLifeTextFix, localBringToLife, getCaller4, getErrorStack, forEach, getBindings, getExports, matchstr, filter4, allEqual, count, isNativeFunction, repeat, eat, getIndentAndText, StopWatch, stringDictSetter, getFunctionInfo, runRef, toLines, hasCallable, getProseWords, tally, paramify, codeSplit, debugConfig, logConfig, blueColon, toStringArgument3, stringCallable, simpleBinding, dashSplit4, appendBelow, appendAbove, removeLineComments, prependIfNecessary, smartDedent4, blueSandwich, walk4, findLineIndex, parseAB, applyTransform, kebabCase, getExcerpt, sortObject, buildFunction, maybeSort, parseFunction, isTypable, frontMatter, dictEntry, insertAfterIndex, State, bindMethods, cpop, tagRE, toggle2, createFunction2, assignIncrementedIndex, ufa, assignArray, regexFromComment, createParsersFromObject, imatch, globalConsoleDebug, bindMethodsAndState, isQuestion, oxfordComma, isUpperCase, getFunctionIdentifier, filter3, match, getMatch, alternatef, reCombine, assertion2, deepEqual, hasDollar, so, deepAssign, Tally, getFunctionNames, throwError, notEqual, tryString, prettyPrintCodeSnippet, prettyPrintErrorStack, iter, quotify, transformerf, assign, defineBinding, jspy, linebreak, stringCall2, reduce3, getClassParameters, assignOnTop2, isIdentifier, ndy, dashSplit3, runFunctionFromRef, equalf, alphabet, stateGetterFromSchema, mreplace, require, topLineComment, isChinese, replacef, ignoref, codeLibrary, splitLines, addArgumentQuotes, getBindings2, addCaret, mget2, getStartingConfig, incrementalEat, strlen, hr, setOnce, unescapeHtml, oxford, breakerf, runTests, map3, dateSplit, transformDict, walk3, toRegExp, tryAgainf, assertNotNull, getArgumentObject, isArgumentObject, typef, requireArg, keyAndValue, assignf, stateGetter3, objectFromArguments2, assignDefaults, transformValue, assign3, assignFresh3, evaluate3, scopedEvaluator, objectFromArguments, enforce, sub, filterObject, extractStartingJsonLikeConfig, unbrackify, newlineIndent2, deleteLine, both, normalizeIndent, getComment, secondComment, isStringRegExp, dashSplit2, clock, warning, errorStringify, alert, labelCase, bottomComment, stringCompose, getAnyIdentifier, chalkf, getNumbers, partitions, has, addUnit, toCallable, unquote, filter2, warn2, join2, caller2, assignOnce, longShort, shortLong, argPop, caller, assignOnTop, toggle, defineWindow, unescapeNewlines, escapeQuotes, unescapeQuotes, escapeNewlines, setAliases, announceCaller, removeStartingComments, smartBind, assignExisting, isObjectWithKey, eatStart, modularIncrementItem, getRegex, runFunction, isObjectLikeArray, itemGetter2, getAllKeys, prefixSlice, hasQuotes, assertion, diff, toggleState, initState, dunder, objectGetter, superTransform, popFilter, testRunner, assert2, insertAtDollar, popEmptyLine, getOptions, mergeSpecs, sortByKeys, map2, strictMessengerAssert, smartSplit, chalk4, typeLog, getFunctionName, Clock, search3, MyError, fuzzyMatch3, debugDisplay, getCaller3, messengerAssert, camelSlice, setPrototype, assignAliases, display, modifyNumber, toDict, setPush, modularIncrementIndex, longstamp, popIndex, toggleOnOff, locWrap, walk2, typeMatch, prettyStringify, getIdentifiers, CustomError, argMatch, brackify2, smartestDedent, modularIncrementNumber, AbstractMethodError, allUnique, Trie, boundarySplit, numberBoundarySplit, nodeLog, getFirst, defineProperty, supermix, partial, timeLog, timestamp, raise, getIdentifier, conditionalPrefix, conditionalSuffix, QueryList, fuzzyMatch2, buildDict, getTextAndCommand, sprawlFactory, getParameters2, pushf, intersection, union, blue, green, sandwich, getLastSpaces, smartDedent3, red, sort, debounce, checkValue, getCodeChunks, logf, boundary, myError, conditional, isStringFunction, toSpaces, objectf, searchAll, difference, singleQuote, itemGetter, slice2, mergeObjects, once, dashSplit, nchalk, coerceToObject, ArrayState, exporter2, indent2, iterator, removeAllComments, countParams, cumulativeSchemaAssign, argKwargSplit, argParse, removeInlineComments, getFrontMatter, hasHtmlSuffix, lazyArray, isThisFunction, escapeHTML, getKwargs2, search2, toStringArgument, createFuzzyMatch, edit2, splice, zip, merge2, argArgsKwargs, fill2, chalk, vueWrap, splitArray, splitArray2, warn, makeRunner2, searchf2, smartDedent2, dedent2, toArray2, stateGetter2, sortByIndex, IndexedCache, argo, curry2, doUntil2, evaluate2, findall2, findIndex2, findItem2, getCaller2, getErrorStack2, isJson, indexGetter2, insert2, pop2, parseError2, remove2, reduce2, testf2, type2, unshift2, waterfall2, xsplit2, Cache, cumulativeAssign, replaceBefore, topComment, isAsyncFunction, mapSort, getFileURI, getQuotes, isClassObject, isInitialized, getFallback, bindingRE, addObjectOrObjectProperty, forDoubles, isCss, log, iterate, backAndForth, round, iteratorWrapper, toJSON, isFromMap, toString, empty, conditionalString, getConfigArg, hasKey, errorWrap, successWrap, check, toPoints, bind, mixinAliases, isPercentage, isBasicType, reducerStrategy, gather, entries, stateGetter, methodCase, vueCase, push2, smarterIndent, lineSplit, Store, isSingleLetter, prepareText, isSymbol, getShortest, slice, KeyError, deepCopy, argsKwargs, isError, isColor, list, objectEditor, matchall, makeFastRunner, announce, hasLetter, filter, reduce, stringCall, capitalizeName, stop, proseCase, lineDitto, mixinSetters, modularIncrement, distinct, definedSort, groupBy, reWrap2, fuzzyMatch, isPlural, parseError, isPrimitiveArray, callableArgsKwargs, waterfall, defineVariable, info, flat2D, splitThePage, handleError, dedent, TypeAssertion, createFunction, pluralize, remove, Group, PageStorage, Storage, UniqueStorage, Watcher, arrayToDict, addProperty, addQuotes, argWrapFactory, assert, abrev, abf, addExtension, assignFresh, antif, atFirst, atSecond, backspace, bindObject, breaker, blockQuote, brackify, bringToLife, comment, countCaptureGroups, capitalizeTitle, classMixin, callableRE, camelToTitle, curry, createVariable, changeExtension, curryStart, curryEnd, capitalize, copy, camelCase, compose, char2n, camelToDash, deepMerge, datestamp, doublef, dictSetter, dictSetter2, dsearch, doUntil, dashCase, doubleQuote, dict, dictGetter, depluralize, dreplace, dictf, endsWithWord, exporter, edit, exists, evaluate, extend, find, flatMap, fill, fixUrl, functionGetter, findall, fixPath, flat, fparse, findIndex, firstLine, ftest, getKwargs, getFirstName, getBindingName, getParameters, getLastWord, getCodeWords, getCodeWords2, getIndent, getExtension, getLast, getLongest, getChunks, getCaller, getStackTrace, getConstructorName, getFirstWord, getWords, getSpaces, hasComma, hasSpaces, hasHtml, hasBracket, hasNewline, hasCaptureGroup, hasEquals, hasValue, hasCamelCase, hasNumber, hackReplace, insert, indexGetter, incrementf, isCallable, isQuote, isEven, isOdd, isLast, isHTML, isNode, interweave, inferLang, isString, isArray, isObject, isDefined, isFunction, isPrimitive, isNumber, isSet, isNestedArray, indent, isNull, isWord, isBoolean, isRegExp, identity, isObjectLiteral, isJsonParsable, isCapitalized, isNewLine, isObjectArray, isStringArray, isClassFunction, joinSpaces, join, keyArrayToObject, lowerCase, linebreakRE, len, lineGetter, lineCount, lastLine, logConsole, makeRunner, mixin, modularf, matchGetter, merge, mget, map, mergeOnTop, mergeToObject, mapFilter, noop, nestPush, no, newlineIndent, n2char, objectWalk, overlap, objectToString, opposite, pipe, parseTopAttrs, pascalCase, partition, parens, push, pop, parseJSON, rigidSort, removeQuotes, rep, removeComments, range, removeExtension, rescape, reverse, reWrap, reduceToString, repeatUntil, swapKey, sayhi, swap, splitMapJoin, splitCamel, smallify, search, stringify, shared, smartDedent, stringBreaker, sleep, split, snakeCase, stringArgument, sorted, splitOnce, searchf, secondLine, titleCase, textOrJson, toNumber, toArgument, toNestedArray, test, type, tail, transformObject, trim, testf, toArray, templater, totalOverlap, upperCase, unique, uncapitalize, unzip, wrap, walk, wrapf, xsplit, yes, zip2} from "/home/kdog3682/2023/utils.js"
// import {lazyObjectTraversal} from "/home/kdog3682/2023/lazyObjectParser2.js"
import {htmlParser} from "/home/kdog3682/2023/htmlParser2.js"
import { ComponentState } from "./ComponentState.js"

// should give the correct dest

const lopBlock = {
    name: "lop",
    remove: true,
    regex: /(^[a-zA-Z][$\w-_.]*):$/,
    traversal: lazyObjectTraversal,
    handler(node, value) {
        if (node.depth > 0) {
            node.parent.assign(value)
        } else {
            this.assign(value)
        }
    }
}


/* @bookmark 1709048462 todo colonBlock */
const colonBlock = {
    // spaces are allowed for the second argument
    // all colons
    name: "label",
    remove: true,
    regex: /([a-zA-Z][$\w-_.]*) *: +(\S.*)/,
    handler(node, a, b) {
        if (node.depth == 0) {
            this.assign(a, toArguments(b))
        } else {
            node.parent.assign('style', csx.converter(a, b))
        }
    },
}


const functionBlock = {
    name: "function",
    regex: /^(?:async )?(?:function!? +)?([\w$]+)\(.*?{/,
    remove: true,
    handler(node, name) {
        this.handleFunction(name, node.text, node)
    }
}


const commentBlock = {
    name: "comments",
    type: "leaf",
    regex: /^\/\//,
    remove: true
}


const vueBracketTextBlock = {
    name: "vueBracketText",
    type: "leaf",
    assign: "node",
    regex: /^{+(.*?)}*$/,
    handler(node, match) {
        this.implicits.push(match)
        return {
            tag: node.parent.state.tag == "span" ? "span" : "div",
            classes: [dashCase(match)],
            text: wrap(match, "{{}}")
        }
    }
}


const vueTransitionBlock = {
    name: "vueTransition",
    regex: /^transition(?: +(.+))?/,
    assign: "node",
    type: "branch",
    handler(node, match) {
        const attrs = {
            mode: "out-in",
            name: "fade"
        }
        return { tag: "transition", attrs }
    }
}


const vueElseBlock = {
    name: "vueElse",
    regex: /^else$/,
    type: "branch",
    assign: "node",
    handler() {
        return { tag: "template", attrs: { "v-else": "" } }
    }
}


const propBlock = {
    name: "prop",
    regex: /^:(\S+)(?: *= *(\S.+))?$/,
    remove: true,
    type: "leaf",
    handler(node, a, b) {
        if (empty(b)) {
            b = a
        }
        this.implicits.push(b)
        node.parent.assign("props", a, b)
    }
}


const attrBlock = {
    name: "attr",
    regex: /^(\w\S*) += +(".*?"|\$?(?:\w\S.*|\d+))/,
    type: "leaf",
    assign: "parent",
    remove: true,
    handler(node, a, b) {
        // 02-07-2024 added this quote fix
        if (b.startsWith('"')) {
            b = removeQuotes(b)
        }
        if (node.parent.noLongerTrackHashNodeAttrs && mergeIntoHashNode(node)) {
            return 
        }
        if (node.newlines && node.parent.isHashNode) {
            node.parent.noLongerTrackHashNodeAttrs = true
        }
        const singles = ["autofocus"]
        const base = ["style", "class"]

        if (base.includes(a)) {
            return [a, b]
        } else if (vueNativeAttrs.includes(a)) {
            this.implicits.push(b)
            return ["attrs", a, b]
        } else if (vueNativeAttrs.includes("v-" + a)) {
            this.implicits.push(b)
            return ["attrs", "v-" + a, b]
        } else if (/^v-/.test(a)) {
            this.implicits.push(b)
            return ["directives", a, b]
        } else if (singles.includes(a)) {
            return ["attrs", a, ""]
        } else {
            return ["attrs", a, b]
        }
    }
}


const ifBlock = {
    name: "if",
    assign: "node",
    type: "branch",
    regex: /^(if|elif) +(\w.+)/,
    handler(node, a, b) {
        this.implicits.push(b)
        const ref = {
            if: "v-if",
            elif: "v-else-if"
        }
        const key = ref[a]
        return { tag: "template", attrs: { [key]: b } }
    }
}


const forBlock = {
    name: "for",
    type: "branch",
    regex: /^for +\(?(\w+)(?:, *(\w+)\)?) +in +(.+)/,
    handler(node, key, index, expr) {
        this.implicits.push(expr)
        this.implicits.push({type: 'ignore', name: key})
        const text = index
            ? `(${key}, ${index}) in ${expr}`
            : `${key} in ${expr}`

        node.firstChild.assign("attrs", "v-for", text)
    }
}


const defaultBlock = {
    name: "html",
    regex: /.+/,
    assign: "node",
    handler(node, s) {
        const value = htmlParser(s)
        extend(this.implicits, value.implicits)
        return value
    }
}

const onEnter = [
    lopBlock,
    colonBlock,
    functionBlock,
    commentBlock,
    vueBracketTextBlock,
    vueTransitionBlock,
    vueElseBlock,
    propBlock,
    attrBlock,
    forBlock,
    ifBlock,
    defaultBlock,
]

function parse(s) {
    let node = new StateContextNode()
    let root = node
    let currentInd = 0
    let tokens = getLineTokens(s)
    // console.log(tokens); throw "tokens"
    for (const token of tokens) {
        const ind = token.ind
        if (ind > currentInd) {
            node = node.enter()
        } else if (ind < currentInd) {
            const n = currentInd - ind
            node = node.exit(n)
        }
        const tokenValue = {
            text: token.text,
        }
        // node.append(tokenValue)
        node.append(token)
        // throw node
    }
    return root
}

function vuetify(s) {
    const options = {
        onEnter,
        onEnd(node) {
            // return this.build(node)
        },
    }

    const traversal = new Traversal(lazyObjectTraversal)
    // const traversal = new Traversal(options, new ComponentState)
    const node = parse(s)
    const value = traversal.traverse(node)
    // console.log(node.toJSON())
    // console.log('hi')
    // console.log(node)
    return value
    // console.loggg(node.toJSON())
    // return value
}

const s = `
stroke:
    paint: blue
`
console.log(vuetify(s))

