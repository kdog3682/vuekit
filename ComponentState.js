import {xmlString} from "/home/kdog3682/2024-javascript/js-toolkit/xmlString.js"
/* prettier-ignore */ import {assertObjectValue, exit, fooga, strcall, getLongest2, must, mconfig, unreachable, notify, storager, joiner, removeVeryStartingComments, ireplace, removeCommentsInPlace, editf, getLineTokens, IndexedStore, abstractError, bool, xassert, getSetLines, inMiddle, replaceLast, ensureExtension, multipleReplacer, getGradeLevel, constructEdit, getYear, Modulus, wrapClassMethods, proseReplacer, parseComments, parseFunctionDictComments, todo, dictAssertion, boundModularIncrement, construct, reduceToString2, pageTurner, assignCumulative, defaultMergeStrategy, dictSetter3, toArguments, reTemplate, parseFrontmatter, typeAssertion, defineGetter, assignAllowed, simpleRecursiveWalk, simpleArgument, exprTemplater, stringifyIfNotPrimitive, panic, stringerf, wrapFunction, regexTemplater, iso8601, strftime, walkChildEntries, getFiletype, matchf, isUrl, looksLikeFunction, toArgument2, notNull, CumulativeStorage2, simpleAssign, findAndMatch, infuseObjectArray, regexGetter, splitArg, isJavascriptComment, runTest, everyOther, splitByRange, get_regex, getImports, isJavascriptFile, isValidDateString, WriteObject, equalityf, group2, splitOnce2, dedent4, isLowerCase, looksLikeRegExpString, isRegExpString, getDependencies, camelSplit, toggle3, countf, isLiteralObject, bindMethodsAndState2, call, mget3, looks_like_object_function, create_functions_from_master, toStringArgumentPretty, codeChunks, smart_map, run_tests, hasStartingCallable, mapTemplate, aliaser, fixSelector, htmlTags, removePythonComments, simpleStringBreaker, colonConfig, operations, error, redColon, so2, group, parseSingleLineJson, Items, findDependencies, tryf, find4, localeString, cssComment, colonConfigf, trimArray, parseCallable, bringToLifeTextFix, localBringToLife, getCaller4, getErrorStack, forEach, getBindings, getExports, matchstr, filter4, allEqual, count, isNativeFunction, repeat, eat, getIndentAndText, StopWatch, stringDictSetter, getFunctionInfo, runRef, toLines, hasCallable, getProseWords, tally, paramify, codeSplit, debugConfig, logConfig, blueColon, toStringArgument3, stringCallable, simpleBinding, dashSplit4, appendBelow, appendAbove, removeLineComments, prependIfNecessary, smartDedent4, blueSandwich, walk4, findLineIndex, parseAB, applyTransform, kebabCase, getExcerpt, sortObject, buildFunction, maybeSort, parseFunction, isTypable, frontMatter, dictEntry, insertAfterIndex, State, bindMethods, cpop, tagRE, toggle2, createFunction2, assignIncrementedIndex, ufa, assignArray, regexFromComment, createParsersFromObject, imatch, globalConsoleDebug, bindMethodsAndState, isQuestion, oxfordComma, isUpperCase, getFunctionIdentifier, filter3, match, getMatch, alternatef, reCombine, assertion2, deepEqual, hasDollar, so, deepAssign, Tally, getFunctionNames, throwError, notEqual, tryString, prettyPrintCodeSnippet, prettyPrintErrorStack, iter, quotify, transformerf, assign, defineBinding, jspy, linebreak, stringCall2, reduce3, getClassParameters, assignOnTop2, isIdentifier, ndy, dashSplit3, runFunctionFromRef, equalf, alphabet, stateGetterFromSchema, mreplace, require, topLineComment, isChinese, replacef, ignoref, codeLibrary, splitLines, addArgumentQuotes, getBindings2, addCaret, mget2, getStartingConfig, incrementalEat, strlen, hr, setOnce, unescapeHtml, oxford, breakerf, runTests, map3, dateSplit, transformDict, walk3, toRegExp, tryAgainf, assertNotNull, getArgumentObject, isArgumentObject, typef, requireArg, keyAndValue, assignf, stateGetter3, objectFromArguments2, assignDefaults, transformValue, assign3, assignFresh3, evaluate3, scopedEvaluator, objectFromArguments, enforce, sub, filterObject, extractStartingJsonLikeConfig, unbrackify, newlineIndent2, deleteLine, both, normalizeIndent, getComment, secondComment, isStringRegExp, dashSplit2, clock, warning, errorStringify, alert, labelCase, bottomComment, stringCompose, getAnyIdentifier, chalkf, getNumbers, partitions, has, addUnit, toCallable, unquote, filter2, warn2, join2, caller2, assignOnce, longShort, shortLong, argPop, caller, assignOnTop, toggle, defineWindow, unescapeNewlines, escapeQuotes, unescapeQuotes, escapeNewlines, setAliases, announceCaller, removeStartingComments, smartBind, assignExisting, isObjectWithKey, eatStart, modularIncrementItem, getRegex, runFunction, isObjectLikeArray, itemGetter2, getAllKeys, prefixSlice, hasQuotes, assertion, diff, toggleState, initState, dunder, objectGetter, superTransform, popFilter, testRunner, assert2, insertAtDollar, popEmptyLine, getOptions, mergeSpecs, sortByKeys, map2, strictMessengerAssert, smartSplit, chalk4, typeLog, getFunctionName, Clock, search3, MyError, fuzzyMatch3, debugDisplay, getCaller3, messengerAssert, camelSlice, setPrototype, assignAliases, display, modifyNumber, toDict, setPush, modularIncrementIndex, longstamp, popIndex, toggleOnOff, locWrap, walk2, typeMatch, prettyStringify, getIdentifiers, CustomError, argMatch, brackify2, smartestDedent, modularIncrementNumber, AbstractMethodError, allUnique, Trie, boundarySplit, numberBoundarySplit, nodeLog, getFirst, defineProperty, supermix, partial, timeLog, timestamp, raise, getIdentifier, conditionalPrefix, conditionalSuffix, QueryList, fuzzyMatch2, buildDict, getTextAndCommand, sprawlFactory, getParameters2, pushf, intersection, union, blue, green, sandwich, getLastSpaces, smartDedent3, red, sort, debounce, checkValue, getCodeChunks, logf, boundary, myError, conditional, isStringFunction, toSpaces, objectf, searchAll, difference, singleQuote, itemGetter, slice2, mergeObjects, once, dashSplit, nchalk, coerceToObject, ArrayState, exporter2, indent2, iterator, removeAllComments, countParams, cumulativeSchemaAssign, argKwargSplit, argParse, removeInlineComments, getFrontMatter, hasHtmlSuffix, lazyArray, isThisFunction, escapeHTML, getKwargs2, search2, toStringArgument, createFuzzyMatch, edit2, splice, zip, merge2, argArgsKwargs, fill2, chalk, vueWrap, splitArray, splitArray2, warn, makeRunner2, searchf2, smartDedent2, dedent2, toArray2, stateGetter2, sortByIndex, IndexedCache, argo, curry2, doUntil2, evaluate2, findall2, findIndex2, findItem2, getCaller2, getErrorStack2, isJson, indexGetter2, insert2, pop2, parseError2, remove2, reduce2, testf2, type2, unshift2, waterfall2, xsplit2, Cache, cumulativeAssign, replaceBefore, topComment, isAsyncFunction, mapSort, getFileURI, getQuotes, isClassObject, isInitialized, getFallback, bindingRE, addObjectOrObjectProperty, forDoubles, isCss, log, iterate, backAndForth, round, iteratorWrapper, toJSON, isFromMap, toString, empty, conditionalString, getConfigArg, hasKey, errorWrap, successWrap, check, toPoints, bind, mixinAliases, isPercentage, isBasicType, reducerStrategy, gather, entries, stateGetter, methodCase, vueCase, push2, smarterIndent, lineSplit, Store, isSingleLetter, prepareText, isSymbol, getShortest, slice, KeyError, deepCopy, argsKwargs, isError, isColor, list, objectEditor, matchall, makeFastRunner, announce, hasLetter, filter, reduce, stringCall, capitalizeName, stop, proseCase, lineDitto, mixinSetters, modularIncrement, distinct, definedSort, groupBy, reWrap2, fuzzyMatch, isPlural, Element, parseError, isPrimitiveArray, callableArgsKwargs, waterfall, defineVariable, info, flat2D, splitThePage, handleError, dedent, TypeAssertion, createFunction, pluralize, remove, Group, PageStorage, Storage, UniqueStorage, Watcher, arrayToDict, addProperty, addQuotes, argWrapFactory, assert, abrev, abf, addExtension, assignFresh, antif, atFirst, atSecond, backspace, bindObject, breaker, blockQuote, brackify, bringToLife, comment, countCaptureGroups, capitalizeTitle, classMixin, callableRE, camelToTitle, curry, createVariable, changeExtension, curryStart, curryEnd, capitalize, copy, camelCase, compose, char2n, camelToDash, deepMerge, datestamp, doublef, dictSetter, dictSetter2, dsearch, doUntil, dashCase, doubleQuote, dict, dictGetter, depluralize, dreplace, dictf, endsWithWord, exporter, edit, exists, evaluate, extend, find, flatMap, fill, fixUrl, functionGetter, findall, fixPath, flat, fparse, findIndex, firstLine, ftest, getKwargs, getFirstName, getBindingName, getParameters, getLastWord, getCodeWords, getCodeWords2, getIndent, getExtension, getLast, getLongest, getChunks, getCaller, getStackTrace, getConstructorName, getFirstWord, getWords, getSpaces, hasComma, hasSpaces, hasHtml, hasBracket, hasNewline, hasCaptureGroup, hasEquals, hasValue, hasCamelCase, hasNumber, hackReplace, insert, indexGetter, incrementf, isCallable, isQuote, isEven, isOdd, isLast, isHTML, isNode, interweave, inferLang, isString, isArray, isObject, isDefined, isFunction, isPrimitive, isNumber, isSet, isNestedArray, indent, isNull, isWord, isBoolean, isRegExp, identity, isObjectLiteral, isJsonParsable, isCapitalized, isNewLine, isObjectArray, isStringArray, isClassFunction, joinSpaces, join, keyArrayToObject, lowerCase, linebreakRE, len, lineGetter, lineCount, lastLine, logConsole, makeRunner, mixin, modularf, matchGetter, merge, mget, map, mergeOnTop, mergeToObject, mapFilter, noop, nestPush, no, newlineIndent, n2char, objectWalk, overlap, objectToString, opposite, pipe, parseTopAttrs, pascalCase, partition, parens, push, pop, parseJSON, rigidSort, removeQuotes, rep, removeComments, range, removeExtension, rescape, reverse, reWrap, reduceToString, repeatUntil, swapKey, sayhi, swap, splitMapJoin, splitCamel, smallify, search, stringify, shared, smartDedent, stringBreaker, sleep, split, snakeCase, stringArgument, sorted, splitOnce, searchf, secondLine, titleCase, textOrJson, toNumber, toArgument, toNestedArray, test, type, tail, transformObject, trim, testf, toArray, templater, totalOverlap, upperCase, unique, uncapitalize, unzip, wrap, walk, wrapf, xsplit, yes, zip2} from "/home/kdog3682/2023/utils.js"
import * as csx from "/home/kdog3682/2024-javascript/csx/main.js"
import {
    traverse,
    simpleTraverse,
    Traversal,
    inAndOut
} from "/home/kdog3682/2024-javascript/js-toolkit/traverse.js"
import * as variables from "/home/kdog3682/2023/variables.js"
// import { xmlString } from "/home/kdog3682/2023/xmlString2.js"
export { ComponentState }
import * as helpers from "./helpers.js"

const stringifyOptions = {
    magic: true,
    max_length: 0,
    lang: "javascript",
    beforeStart(component) {
        sortObject(component, variables.vueComponentOptionKeys, [
            "template",
            "props",
            "name"
        ])
        return component
    }
}
class ComponentState {
    wrap2(node, children) {
        if (node.computedLopStyle) {
            const func = buildFunction({
                body: node.computedLopStyle,
                bodyWrapper: "csx.converter($1, Object)"
            })
            const name = this.namer("computedLopStyle")
            this.addFunction("computed", name, eval(parens(func)))
            node.assign("props", "style", name)
        }
        if (
            node.state.component &&
            children.length &&
            children[0].tag != "template"
        ) {
            const firstChild = {
                attrs: {
                    "v-slot:default": "slot"
                },
                tag: "template",
                children: children
            }
            return {
                ...node.state,
                children: [firstChild]
            }
        } else {
            return {
                ...node.state,
                children,
            }
        }
    }
    wrap2(state) {
        const fn = xmlString
        const runner = makeStateRunner(fn)
        return runner(state)
        
    }
    wrap(node, children) {
        if (node.computedLopStyle) {
            const func = buildFunction({
                body: node.computedLopStyle,
                bodyWrapper: "csx.converter($1, Object)"
            })
            const name = this.namer("computedLopStyle")
            this.addFunction("computed", name, eval(parens(func)))
            node.assign("props", "style", name)
            // node.assign('attrs', 'v-lop', name)
        }
        return xmlString(node.state, children)
        if (
            node.state.component &&
            children.length &&
            children[0].tag != "template"
        ) {
            const payload = xmlString(
                {
                    attrs: {
                        "v-slot:default": "slot"
                    },
                    tag: "template"
                },
                children
            )
            return xmlString(node.state, [payload])
        }
        return xmlString(node.state, children)
    }
    build(node, children) {
        // throw getCaller(1)
        // throw 'a'
        // console.log(children.length); throw "throwing"
        let template = join(children)
        if (children.length > 1) {
            template = xmlString(
                { tag: "div", attrs: { class: this.component.name } },
                [template]
            )
        } else {
            if (!/class/.test(firstLine(template)) && this.component.name) {
                template = template.replace(/>/, ' class="' + this.component.name + '">')
                // hack
            }
        }
        if (this.options.mode == "html") {
            return template
        }
        const component = this.component
        if (!component.render) {
            component.template = newlineIndent(template)
        }
        this.determineAdditionalPropKeys(node)
        return this.toString()
    }
    handleFunction(node) {
        const parent = node.parent
        const [text, opt] = mget3(node.computedText, /^(computed|watch) +/)
        // console.log({text, opt})
        try {
            const funcData = parseFunction(text, Function)
            this.getImplicitDataKeys(text)

            if (parent.uid == 0) {
                this.handleRootFunction(funcData, opt)
            } else {
                this.handleInlineFunction(parent, funcData)
            }
        } catch(e) {
            console.log(e)
            console.speak('unable to handle the function text')
            console.speak('the text is ...', text)
            exit()
        }
    }
    handleRootFunction({ name, fn }, opt) {
        // if (fn.toString().startsWith('function')) {
            // window[name] = fn
        // }
        if (opt) {
            this.assign(opt, name, fn)
        }
        else if (has(variables.vueNativeFunctionKeys, name)) {
            this.assign(name, fn)
        } else if (/^(watch|computed)/.test(name)) {
            const dest = match(name, /^(watch|computed)/)
            // name = name.replace(/^(watch|computed) /, '')
            this.assign(dest, name, fn)
        } else {
            this.assign("methods", name, fn)
        }
    }
    addFunction(dest, name, fn) {
        this.getImplicitDataKeys(fn.toString())
        this.assign(dest, name, fn)
    }

    getImplicitDataKeys(text) {
        const [data, props, numerics] = helpers.getDataAndPropKeys(text)
        extend(this.dataKeys, data)
        extend(this.propKeys, props)
        extend(this.numerics, numerics)
    }

    namer(name) {
        // const rawHeading = node.state.tag || node.state.component || ""
        // const heading = rawHeading ? camelCase(rawHeading, name) : name
        const heading = `__${name}__`
        const tallyKey = this.nameTally.add(heading)
        const keyName = heading + tallyKey
        return keyName
    }
    handleInlineFunction(node, { name, params, fn }) {
        const base = attributionalFunctionRef[name]
        assertObjectValue(attributionalFunctionRef, 'attributionalFunctionRef', name, 'in order for a function to be inline, it must be in the ref. you cannot have computed or anything else implicit here')
        const filteredParams = unique(params, ["e", "$event", "event"])

        const propertyType = base.propertyType // props | events | attrs
        const propertyKey = fparse(base.propertyKey, node)
        const functionLocation = fparse(base.functionLocation, {
            name,
            params: filteredParams
        })
        const keyName = this.namer(name)

        const keyValue = exists(filteredParams)
            ? stringCallable(keyName, filteredParams)
            : keyName

        node.assign(propertyType, propertyKey, keyValue)
        this.assign(functionLocation, keyName, fn)
    }
    constructor(options = {}) {
        this.options = options
        this.component = {}
        this.store = {}
        this.nameTally = new Tally()

        this.dataKeys = []
        this.propKeys = []
        this.numerics = []
        this.implicits = []
    }
    get(...args) {
        return dictGetter(this.component, ...args)
    }
    assign(...args) {
        deepAssign(this.component, ...args)
    }
    toJSON() {
        return this.component
    }
    toString() {
        const key = this.options.mode
        switch (key) {
            case "html":
                return this.component.template
            case 'component':
                return this.component
            case "str":
                return toStringArgumentPretty(this.component, stringifyOptions)
            case "template":
                return this.component.template
            case "var":
                const name = pascalCase(this.component?.name || 'temp')
                return defineBinding(name, this.component, stringifyOptions)
            default: panic('specify this.options.mode: str | template | var | component')
        }
    }
    gatherImplicits(node) {
        const ignored = []
        const implied = []

        const visitor = (node) => {
            if (node.dataKeys) {
                ignored.push(...node.dataKeys)
                this.dataKeys.push(...node.dataKeys)
            }
            if (node.ignored) {
                ignored.push(...node.ignored)
            }
            if (node.implied) {
                for (let parg of node.implied.map(parseImplicit)) {
                    if (ignored.includes(parg)) {
                        continue
                    }
                    if (implied.includes(parg)) {
                        continue
                    }
                    implied.push(parg)
                }
            }
        }

        simpleTraverse(node, visitor)
        return implied
    }
    determineAdditionalPropKeys(node) {
        const baseData = this.get("data") || {}
        const computedKeys = Object.keys(this.component.computed || [])

        const props0 = flat(this.component.props)
        const implicits = this.gatherImplicits(node)
        const implicitDataRef = {
            tracker: {},
        }
        const implicitData = {}
        // console.log(this.dataKeys)
        const filter = (key) => {
            if (key in implicitDataRef) {
                implicitData[key] = implicitDataRef[key]
                return false
            }
            return true
        }
        const undetermined = unique(this.propKeys.concat(implicits)).filter(filter)
        // console.log("undetermined", undetermined)
        // numerics represent mutations ...
        // u can not mutate props ...
        // so this has to be ... valid.

        this.numerics.forEach((numeric, i) => {
            if (!baseData.hasOwnProperty(numeric)) {
                baseData[numeric] = 0
            }
        })
        const _data = helpers.assignFallbackValues(this.dataKeys)
        const data = {}
        // console.log(this.dataKeys, data)
        Object.assign(data, implicitData, _data, baseData)
        const alwaysIgnore = ["slot", "booga"]

        const ignore = Object.keys(data)
            .concat(computedKeys)
            .concat(alwaysIgnore)
        const props1 = unique(undetermined, ignore)
        const props = unique(props0.concat(props1))

        if (exists(data)) {
            const dataFn = buildFunction({ name: "data", body: data }, eval)
            // console.log(dataFn())
            this.component.data = dataFn
        }
        if (exists(props)) {
            this.component.props = props
        }
    }
}

const attributionalFunctionRef = {
    style: {
        functionLocation({ params }) {
            if (params?.length) {
                return "methods"
            }
            return "computed"
        },
        propertyType: "props",
        propertyKey: "style"
    },
    class: {
        functionLocation: "computed",
        propertyType: "props",
        propertyKey: "class"
    },
    click: {
        functionLocation: "methods",
        propertyType: "events",
        propertyKey(node) {
            return node.state.component ? "click.native" : "click"
        }
    },
    mouseleave: {
        functionLocation: "methods",
        propertyType: "events",
        propertyKey: "mouseleave"
    },
    mousemove: {
        functionLocation: "methods",
        propertyType: "events",
        propertyKey: "mousemove"
    },
    mouseover: {
        functionLocation: "methods",
        propertyType: "events",
        propertyKey: "mouseover"
    },
    enter: {
        functionLocation: "methods",
        propertyType: "events",
        propertyKey: "keydown.enter"
    },
    emit: {
        functionLocation: "methods",
        propertyType: "events",
        propertyKey: "keydown.enter"
    }
}
function parseImplicit(arg) {
    if (/^\w+\./.test(arg)) {
        return getFirstWord(arg)
    }
    return arg
    // const r = /^\(?(\w+)(?:, *(\w+)\)?) +in +(.+)/
    // return must(match, arg, r)
}


function makeStateRunner(fn) {
    const runner = (state) => {
        const children = state.children
        if (children) {
            return fn(state, children.map(runner))
        }
        return fn(state)
    }
    return runner
}
