export {
    assignFallbackValues,
    getDataAndPropKeys,
    // getTypedThisBindings,
}
/* prettier-ignore */ import {fooga, strcall, getLongest2, must, mconfig, unreachable, notify, storager, joiner, removeVeryStartingComments, ireplace, removeCommentsInPlace, editf, getLineTokens, IndexedStore, abstractError, bool, xassert, getSetLines, inMiddle, replaceLast, ensureExtension, multipleReplacer, getGradeLevel, constructEdit, getYear, Modulus, wrapClassMethods, proseReplacer, parseComments, parseFunctionDictComments, todo, dictAssertion, boundModularIncrement, construct, reduceToString2, pageTurner, assignCumulative, defaultMergeStrategy, dictSetter3, toArguments, reTemplate, parseFrontmatter, typeAssertion, defineGetter, assignAllowed, simpleRecursiveWalk, simpleArgument, exprTemplater, stringifyIfNotPrimitive, panic, stringerf, wrapFunction, regexTemplater, iso8601, strftime, walkChildEntries, getFiletype, matchf, isUrl, looksLikeFunction, toArgument2, notNull, CumulativeStorage2, simpleAssign, findAndMatch, infuseObjectArray, regexGetter, splitArg, isJavascriptComment, runTest, everyOther, splitByRange, get_regex, getImports, isJavascriptFile, isValidDateString, WriteObject, equalityf, group2, splitOnce2, dedent4, isLowerCase, looksLikeRegExpString, isRegExpString, getDependencies, camelSplit, toggle3, countf, isLiteralObject, bindMethodsAndState2, call, mget3, looks_like_object_function, create_functions_from_master, toStringArgumentPretty, codeChunks, smart_map, run_tests, hasStartingCallable, mapTemplate, aliaser, fixSelector, htmlTags, removePythonComments, simpleStringBreaker, colonConfig, operations, error, redColon, so2, group, parseSingleLineJson, Items, findDependencies, tryf, find4, localeString, cssComment, colonConfigf, trimArray, parseCallable, bringToLifeTextFix, localBringToLife, getCaller4, getErrorStack, forEach, getBindings, getExports, matchstr, filter4, allEqual, count, isNativeFunction, repeat, eat, getIndentAndText, StopWatch, stringDictSetter, getFunctionInfo, runRef, toLines, hasCallable, getProseWords, tally, paramify, codeSplit, debugConfig, logConfig, blueColon, toStringArgument3, stringCallable, simpleBinding, dashSplit4, appendBelow, appendAbove, removeLineComments, prependIfNecessary, smartDedent4, blueSandwich, walk4, findLineIndex, parseAB, applyTransform, kebabCase, getExcerpt, sortObject, buildFunction, maybeSort, parseFunction, isTypable, frontMatter, dictEntry, insertAfterIndex, State, bindMethods, cpop, tagRE, toggle2, createFunction2, assignIncrementedIndex, ufa, assignArray, regexFromComment, createParsersFromObject, imatch, globalConsoleDebug, bindMethodsAndState, isQuestion, oxfordComma, isUpperCase, getFunctionIdentifier, filter3, match, getMatch, alternatef, reCombine, assertion2, deepEqual, hasDollar, so, deepAssign, Tally, getFunctionNames, notEqual, tryString, prettyPrintCodeSnippet, prettyPrintErrorStack, iter, quotify, transformerf, assign, defineBinding, jspy, linebreak, stringCall2, reduce3, getClassParameters, assignOnTop2, isIdentifier, ndy, dashSplit3, runFunctionFromRef, equalf, alphabet, stateGetterFromSchema, mreplace, require, topLineComment, isChinese, replacef, ignoref, codeLibrary, splitLines, addArgumentQuotes, getBindings2, addCaret, mget2, getStartingConfig, incrementalEat, strlen, hr, setOnce, unescapeHtml, oxford, breakerf, runTests, map3, dateSplit, transformDict, walk3, toRegExp, tryAgainf, assertNotNull, getArgumentObject, isArgumentObject, typef, requireArg, keyAndValue, assignf, stateGetter3, objectFromArguments2, assignDefaults, transformValue, assign3, assignFresh3, evaluate3, scopedEvaluator, objectFromArguments, enforce, sub, filterObject, extractStartingJsonLikeConfig, unbrackify, newlineIndent2, deleteLine, both, normalizeIndent, getComment, secondComment, isStringRegExp, dashSplit2, clock, warning, errorStringify, alert, labelCase, bottomComment, stringCompose, getAnyIdentifier, chalkf, getNumbers, partitions, has, addUnit, toCallable, unquote, filter2, warn2, join2, caller2, assignOnce, longShort, shortLong, argPop, caller, assignOnTop, toggle, defineWindow, unescapeNewlines, escapeQuotes, unescapeQuotes, escapeNewlines, setAliases, announceCaller, removeStartingComments, smartBind, assignExisting, isObjectWithKey, eatStart, modularIncrementItem, getRegex, runFunction, isObjectLikeArray, itemGetter2, getAllKeys, prefixSlice, hasQuotes, assertion, diff, toggleState, initState, dunder, objectGetter, superTransform, popFilter, testRunner, assert2, insertAtDollar, popEmptyLine, getOptions, mergeSpecs, sortByKeys, map2, strictMessengerAssert, smartSplit, chalk4, typeLog, getFunctionName, Clock, search3, MyError, fuzzyMatch3, debugDisplay, getCaller3, messengerAssert, camelSlice, setPrototype, assignAliases, display, modifyNumber, toDict, setPush, modularIncrementIndex, longstamp, popIndex, toggleOnOff, locWrap, walk2, typeMatch, prettyStringify, getIdentifiers, CustomError, argMatch, brackify2, smartestDedent, modularIncrementNumber, AbstractMethodError, allUnique, Trie, boundarySplit, numberBoundarySplit, nodeLog, getFirst, defineProperty, supermix, partial, timeLog, timestamp, raise, getIdentifier, conditionalPrefix, conditionalSuffix, QueryList, fuzzyMatch2, buildDict, getTextAndCommand, sprawlFactory, getParameters2, pushf, intersection, union, blue, green, sandwich, getLastSpaces, smartDedent3, red, sort, debounce, checkValue, getCodeChunks, logf, boundary, myError, conditional, isStringFunction, toSpaces, objectf, searchAll, difference, singleQuote, itemGetter, slice2, mergeObjects, once, dashSplit, nchalk, coerceToObject, ArrayState, exporter2, indent2, iterator, removeAllComments, countParams, cumulativeSchemaAssign, argKwargSplit, argParse, removeInlineComments, getFrontMatter, hasHtmlSuffix, lazyArray, isThisFunction, escapeHTML, getKwargs2, search2, toStringArgument, createFuzzyMatch, edit2, splice, zip, merge2, argArgsKwargs, fill2, chalk, vueWrap, splitArray, splitArray2, warn, makeRunner2, searchf2, smartDedent2, dedent2, toArray2, stateGetter2, sortByIndex, IndexedCache, argo, curry2, doUntil2, evaluate2, findall2, findIndex2, findItem2, getCaller2, getErrorStack2, isJson, indexGetter2, insert2, pop2, parseError2, remove2, reduce2, testf2, type2, unshift2, waterfall2, xsplit2, Cache, cumulativeAssign, replaceBefore, topComment, isAsyncFunction, mapSort, getFileURI, getQuotes, isClassObject, isInitialized, getFallback, bindingRE, addObjectOrObjectProperty, forDoubles, isCss, log, iterate, backAndForth, round, iteratorWrapper, toJSON, isFromMap, toString, empty, conditionalString, getConfigArg, hasKey, errorWrap, successWrap, check, toPoints, bind, mixinAliases, isPercentage, isBasicType, reducerStrategy, gather, entries, stateGetter, methodCase, vueCase, push2, smarterIndent, lineSplit, Store, isSingleLetter, prepareText, isSymbol, getShortest, slice, KeyError, deepCopy, argsKwargs, isError, isColor, list, objectEditor, matchall, makeFastRunner, announce, hasLetter, filter, reduce, stringCall, capitalizeName, stop, proseCase, lineDitto, mixinSetters, modularIncrement, distinct, definedSort, groupBy, reWrap2, fuzzyMatch, isPlural, Element, parseError, isPrimitiveArray, callableArgsKwargs, waterfall, defineVariable, info, flat2D, splitThePage, handleError, dedent, TypeAssertion, createFunction, pluralize, remove, Group, PageStorage, Storage, UniqueStorage, Watcher, arrayToDict, addProperty, addQuotes, argWrapFactory, assert, abrev, abf, addExtension, assignFresh, antif, atFirst, atSecond, backspace, bindObject, breaker, blockQuote, brackify, bringToLife, comment, countCaptureGroups, capitalizeTitle, classMixin, callableRE, camelToTitle, curry, createVariable, changeExtension, curryStart, curryEnd, capitalize, copy, camelCase, compose, char2n, camelToDash, deepMerge, datestamp, doublef, dictSetter, dictSetter2, dsearch, doUntil, dashCase, doubleQuote, dict, dictGetter, depluralize, dreplace, dictf, endsWithWord, exporter, edit, exists, evaluate, extend, find, flatMap, fill, fixUrl, functionGetter, findall, fixPath, flat, fparse, findIndex, firstLine, ftest, getKwargs, getFirstName, getBindingName, getParameters, getLastWord, getCodeWords, getCodeWords2, getIndent, getExtension, getLast, getLongest, getChunks, getCaller, getStackTrace, getConstructorName, getFirstWord, getWords, getSpaces, hasComma, hasSpaces, hasHtml, hasBracket, hasNewline, hasCaptureGroup, hasEquals, hasValue, hasCamelCase, hasNumber, hackReplace, insert, indexGetter, incrementf, isCallable, isQuote, isEven, isOdd, isLast, isHTML, isNode, interweave, inferLang, isString, isArray, isObject, isDefined, isFunction, isPrimitive, isNumber, isSet, isNestedArray, indent, isNull, isWord, isBoolean, isRegExp, identity, isObjectLiteral, isJsonParsable, isCapitalized, isNewLine, isObjectArray, isStringArray, isClassFunction, joinSpaces, join, keyArrayToObject, lowerCase, linebreakRE, len, lineGetter, lineCount, lastLine, logConsole, makeRunner, mixin, modularf, matchGetter, merge, mget, map, mergeOnTop, mergeToObject, mapFilter, noop, nestPush, no, newlineIndent, n2char, objectWalk, overlap, objectToString, opposite, pipe, parseTopAttrs, pascalCase, partition, parens, push, pop, parseJSON, rigidSort, removeQuotes, rep, removeComments, range, removeExtension, rescape, reverse, reWrap, reduceToString, repeatUntil, swapKey, sayhi, swap, splitMapJoin, splitCamel, smallify, search, stringify, shared, smartDedent, stringBreaker, sleep, split, snakeCase, stringArgument, sorted, splitOnce, searchf, secondLine, titleCase, textOrJson, toNumber, toArgument, toNestedArray, test, type, tail, transformObject, trim, testf, toArray, templater, totalOverlap, upperCase, unique, uncapitalize, unzip, wrap, walk, wrapf, xsplit, yes, zip2} from "/home/kdog3682/2023/utils.js"
import * as variables from "../../2023/variables.js"


function assignFallbackValues(keys, external = {}, ignore = []) {
    const data = keys.reduce((acc, key) => {
        if (ignore.includes(key) || /^[$_]/.test(key) || key.length < 3) {
            return acc
        }
        if (acc.hasOwnProperty(key)) {
            return acc
        }
        if (external.hasOwnProperty(key)) {
            acc[key] = external[key]
            return acc
        }
        const value = variables.vueImplicitDataKeyRef.hasOwnProperty(key)
            ? variables.vueImplicitDataKeyRef[key]
            : key.length > 6 && key in external
            ? external[key]
            : /(?:type)$/i.test(key)
            ? ""
            : /(?:dict|json|spec|data)$/i.test(key)
            ? {}
            : /^(?:is|show)[A-Z]/.test(key)
            ? false
            : /(?:count|index|length)$/i.test(key)
            ? 0
            : /item$/i.test(key)
            ? null
            : /ing$/i.test(key)
            ? false
            : /data$/i.test(key)
            ? {}
            : /(?:s|list|array)$/i.test(key)
            ? []
            : ""

        acc[key] = value
        return acc
    }, {})
    return data
}

function getTypedThisBindings(x) {
    const r = /\b(?:this|self)\.([_$]?)([a-zA-Z]\w+)( *(?:([+*\/-])?= +(new )?)|\.(\w+\()|(\())?/g
    const matches = matchall(x, r)
    const transform = (x) => {
        const [_, symbol, a, b, mathOp, newExpression, callable, methodCall] = x
        // console.log({_, symbol, a, b, mathOp, newExpression, callable, methodCall})
        // console.log({_, symbol, a, b, newExpression, arrayMutationMethod})
        const value = (symbol || '') + a
        const type = mathOp
            ? 'numeric'
            : methodCall
            ? 'method'
            : callable
            ? (/splice|push|filter/.test(callable) ? 'data' : 'obj')
            : symbol
            ? 'private'
            : newExpression
            ? 'newExpr'
            : isDefined(b)
            ? 'data'
            : 'props'

        return { type, value }
    }

    return matches.map(transform)
}
function getDataAndPropKeys(x) {
    const data = []
    const props = []
    const numerics = []
    const items = getTypedThisBindings(x)
    for (const {type, value} of items) {
        if (type == 'numeric') {
            numerics.push(value)
        }

        if (type == 'data') {
            data.push(value)
        }
        else if (type == 'props') {
            props.push(value)
        }
    }
    return [data, props, numerics]
}


// console.log(assignFallbackValues(['count', 'index', '_index', 'foo']))

function abc() {
    this.abc = 1 // data
    this.abcd += 1 // data
    this.abcd += 1 // data
    this.$abcd -= 1 // data // private
    this.$abcd = new Foo() // private
    this._abcd += 1 // private
    this.abc.splice(2) // data
    this.def.call() // obj 
    this.foo(this.hannibal) // method  and props
}
// console.log(getDataKeysFromFunction(abc))

function maybeGetAttributes(state, prev) {
    const labelRE = /^[a-zA-Z][$\w-_.]* *:.*/
    const propRE = /^:([a-zA-Z][$\w-_.]*)(?: *= *(.+))/
    const eventRE = /^@([a-zA-Z][$\w-_.]*)(?: *= *(.+))/
    const propertyRE = /^([a-zA-Z][$\w-_.]*) *=(.+)/
    const functionRE = /^(?:async )?function/
    const items = [
        // {
            // regex: functionRE,
            // matchSpaces: true,
            // handler(contents) {
                // const text = toContentString(contents)
                // const results = state.state.handleInlineFunction(text)
                // deepAssign(prev, results)
                // is there quite a bit of duplication here?
            // }
        // },
        {
            regex: labelRE,
            continuous: true,
            raw: true,
            handler(lines) {
                const attributes = lazyObjectParser(lines)
                if (attributes.classes) {
                    todo()
                } else {
                    deepAssign(prev, 'style', csx.converter(attributes))
                }
            }
        },
        {
            regex: propRE,
            handler(a, b) {
                assert(isWord(b), '$1 is being used as a vue prop and therefore must be a word', b)
                deepAssign(prev, 'props', a, b)
                deepAssign(prev, 'implicits', [b])
            }
        },
        {
            regex: eventRE,
            handler(a, b) {
                deepAssign(prev, 'events', a, b)
                // this.token.assign('events', a, b)
            }
        },
        {
            regex: propertyRE,
            handler(a, b) {
                // this.token.assign('properties', a, b)
                deepAssign(prev, 'attrs', a, b)
            }
        }
    ]

    do {
        let current = state.peek()
        let touched = false
        for (let item of items) {
            let m = match(current.text, item.regex)
            if (m) {
                touched = true
                if (item.matchBlock) {
                    unreachable()
                    m = state._getBlock({
                        includeEndpoint: true,
                        includeStartpoint: true,
                    })
                    item.handler.call(state, m)
                    break
                }

                if (item.raw) {
                    m = current
                }

                state.eat()
                if (item.continuous) {
                    const store = [m]
                    while (true) {
                    	current = state.peek()
                        if (m = match(current?.text, item.regex)) {
                            if (item.raw) {
                                m = current
                            }
                            state.eat()
                            store.push(m)
                        } else {
                            item.handler.call(state, store)
                            break
                        }
                    }
                } else {
                    item.handler.call(state, ...toArray2(m))
                }
            } 
            if (touched) {
                break
            }
        }
        if (!touched) {
            break
        }
    } while (state.notDone())
    return prev
}


